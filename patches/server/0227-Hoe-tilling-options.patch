From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: William Blake Galbreath <blake.galbreath@gmail.com>
Date: Fri, 2 Jul 2021 20:54:29 -0500
Subject: [PATCH] Hoe tilling options


diff --git a/src/main/java/net/minecraft/world/item/HoeItem.java b/src/main/java/net/minecraft/world/item/HoeItem.java
index 009dd6b59e27a9413b3ef115468a6d1dd0746d56..22e3992a30a35aa17c03882e97cd0213213c7238 100644
--- a/src/main/java/net/minecraft/world/item/HoeItem.java
+++ b/src/main/java/net/minecraft/world/item/HoeItem.java
@@ -33,15 +33,15 @@ public class HoeItem extends DiggerItem {
     public InteractionResult useOn(UseOnContext context) {
         Level level = context.getLevel();
         BlockPos blockPos = context.getClickedPos();
-        Pair<Predicate<UseOnContext>, Consumer<UseOnContext>> pair = TILLABLES.get(level.getBlockState(blockPos).getBlock());
-        if (pair == null) {
-            return InteractionResult.PASS;
-        } else {
-            Predicate<UseOnContext> predicate = pair.getFirst();
-            Consumer<UseOnContext> consumer = pair.getSecond();
+        // Purpur start
+        var tilling = level.purpurConfig.hoeTilling.get(level.getBlockState(blockPos).getBlock());
+        if (tilling == null) { return InteractionResult.PASS; } else {
+            Predicate<UseOnContext> predicate = tilling.getCondition().getPredicate();
+            Consumer<UseOnContext> consumer = performTilling(tilling);
+            // Purpur end
             if (predicate.test(context)) {
                 Player player = context.getPlayer();
-                level.playSound(player, blockPos, SoundEvents.HOE_TILL, SoundSource.BLOCKS, 1.0F, 1.0F);
+                level.playSound(null, blockPos, SoundEvents.HOE_TILL, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - force sound
                 if (!level.isClientSide) {
                     consumer.accept(context);
                     if (player != null) {
@@ -51,7 +51,7 @@ public class HoeItem extends DiggerItem {
                     }
                 }
 
-                return InteractionResult.sidedSuccess(level.isClientSide);
+                return InteractionResult.SUCCESS; // Purpur - force arm swing
             } else {
                 return InteractionResult.PASS;
             }
@@ -71,6 +71,19 @@ public class HoeItem extends DiggerItem {
         };
     }
 
+    // Purpur start
+    public static Consumer<UseOnContext> performTilling(net.pl3x.purpur.tool.Tilling tilling) {
+        return (context) -> {
+            context.getLevel().setBlock(context.getClickedPos(), tilling.getInto().defaultBlockState(), 11);
+            tilling.getDrops().forEach((drop, chance) -> {
+                if (context.getLevel().random.nextDouble() < chance) {
+                    Block.popResourceFromFace(context.getLevel(), context.getClickedPos(), context.getClickedFace(), new ItemStack(drop));
+                }
+            });
+        };
+    }
+    // Purpur end
+
     public static boolean onlyIfAirAbove(UseOnContext context) {
         return context.getClickedFace() != Direction.DOWN && context.getLevel().getBlockState(context.getClickedPos().above()).isAir();
     }
diff --git a/src/main/java/net/pl3x/purpur/PurpurWorldConfig.java b/src/main/java/net/pl3x/purpur/PurpurWorldConfig.java
index 84c0b76e1cf7af8e78af7af6444a14783eeb4313..b20fdef329a9b1ef4a873502ed33f4769230f28b 100644
--- a/src/main/java/net/pl3x/purpur/PurpurWorldConfig.java
+++ b/src/main/java/net/pl3x/purpur/PurpurWorldConfig.java
@@ -456,6 +456,73 @@ public class PurpurWorldConfig {
         });
     }
 
+    public Map<Block, Tilling> hoeTilling = new HashMap<>();
+    private void toolSettings() {
+        hoeTilling.clear();
+        getMap("tools.hoe.tilling", Map.of(
+                "minecraft:grass_block", Map.of(
+                        "condition", "air_above",
+                        "into", "minecraft:farmland",
+                        "drops", new HashMap<String, Double>()
+                ),
+                "minecraft:dirt_path", Map.of(
+                        "condition", "air_above",
+                        "into", "minecraft:farmland",
+                        "drops", new HashMap<String, Double>()
+                ),
+                "minecraft:dirt", Map.of(
+                        "condition", "air_above",
+                        "into", "minecraft:farmland",
+                        "drops", new HashMap<String, Double>()
+                ),
+                "minecraft:coarse_dirt", Map.of(
+                        "condition", "air_above",
+                        "into", "minecraft:dirt",
+                        "drops", new HashMap<String, Double>()
+                ),
+                "minecraft:rooted_dirt", Map.of(
+                        "condition", "always",
+                        "into", "minecraft:dirt",
+                        "drops", Map.of("minecraft:hanging_roots", 1.0D)
+                ))
+        ).forEach((blockStr, obj) -> {
+            Block block = Registry.BLOCK.get(new ResourceLocation(blockStr));
+            if (block == Blocks.AIR) {
+                PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.hoe.tilling`: " + blockStr);
+                return;
+            }
+            if (!(obj instanceof Map<?, ?> map)) {
+                PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.hoe.tilling." + blockStr + "`");
+                return;
+            }
+            String conditionStr = (String) map.get("condition");
+            Tilling.Condition condition = Tilling.Condition.get(conditionStr);
+            if (condition == null) {
+                PurpurConfig.log(Level.SEVERE, "Invalid condition for `tools.hoe.tilling.condition`: " + conditionStr);
+                return;
+            }
+            String intoStr = (String) map.get("into");
+            Block into = Registry.BLOCK.get(new ResourceLocation(intoStr));
+            if (into == Blocks.AIR) {
+                PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.hoe.tilling.into`: " + intoStr);
+                return;
+            }
+            Map<Item, Double> drops = new HashMap<>();
+            Object dropsObj = map.get("drops");
+            if (dropsObj instanceof Map<?, ?> dropsMap) {
+                dropsMap.forEach((itemStr, chance) -> {
+                    Item item = Registry.ITEM.get(new ResourceLocation(itemStr.toString()));
+                    if (item == Items.AIR) {
+                        PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.hoe.tilling.drops`: " + itemStr);
+                        return;
+                    }
+                    drops.put(item, (double) chance);
+                });
+            }
+            hoeTilling.put(block, new Tilling(condition, into, drops));
+        });
+    }
+
     public boolean useBetterMending = false;
     public boolean alwaysTameInCreative = false;
     public boolean boatEjectPlayersOnLand = false;
diff --git a/src/main/java/net/pl3x/purpur/tool/Tilling.java b/src/main/java/net/pl3x/purpur/tool/Tilling.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3d714653d5b2ddd60269aa85e3416e16f6018b8
--- /dev/null
+++ b/src/main/java/net/pl3x/purpur/tool/Tilling.java
@@ -0,0 +1,61 @@
+package net.pl3x.purpur.tool;
+
+import net.minecraft.world.item.HoeItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.level.block.Block;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public class Tilling {
+    private final Condition condition;
+    private final Block into;
+    private final Map<Item, Double> drops;
+
+    public Tilling(Condition condition, Block into, Map<Item, Double> drops) {
+        this.condition = condition;
+        this.into = into;
+        this.drops = drops;
+    }
+
+    public Condition getCondition() {
+        return condition;
+    }
+
+    public Block getInto() {
+        return into;
+    }
+
+    public Map<Item, Double> getDrops() {
+        return drops;
+    }
+
+    public enum Condition {
+        AIR_ABOVE(HoeItem::onlyIfAirAbove),
+        ALWAYS((useOnContext) -> true);
+
+        private final Predicate<UseOnContext> predicate;
+
+        Condition(Predicate<UseOnContext> predicate) {
+            this.predicate = predicate;
+        }
+
+        public Predicate<UseOnContext> getPredicate() {
+            return predicate;
+        }
+
+        private static final Map<String, Condition> BY_NAME = new HashMap<>();
+
+        static {
+            for (Condition condition : values()) {
+                BY_NAME.put(condition.name(), condition);
+            }
+        }
+
+        public static Condition get(String name) {
+            return BY_NAME.get(name.toUpperCase());
+        }
+    }
+}
