From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: William Blake Galbreath <Blake.Galbreath@GMail.com>
Date: Thu, 3 Dec 2020 17:56:18 -0600
Subject: [PATCH] Lobotomize stuck villagers


diff --git a/src/main/java/net/minecraft/world/entity/npc/Villager.java b/src/main/java/net/minecraft/world/entity/npc/Villager.java
index e520fbbf781d05537a0cbc0025f4cda7f62a1c5f..6e5dd65d3410b805168d6fbfc2705af6cae3c421 100644
--- a/src/main/java/net/minecraft/world/entity/npc/Villager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/Villager.java
@@ -140,6 +140,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }, MemoryModuleType.MEETING_POINT, (entityvillager, holder) -> {
         return holder.is(PoiTypes.MEETING);
     });
+    private boolean isLobotomized = false; public boolean isLobotomized() { return this.isLobotomized; } // Purpur
+    private int notLobotomizedCount = 0; // Purpur
 
     public Villager(EntityType<? extends Villager> entityType, Level world) {
         this(entityType, world, VillagerType.PLAINS);
@@ -197,6 +199,47 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         return this.level.purpurConfig.villagerAlwaysDropExp;
     }
 
+    private boolean checkLobotomized() {
+        int interval = this.level().purpurConfig.villagerLobotomizeCheckInterval;
+        if (this.notLobotomizedCount > 3) {
+            // check half as often if not lobotomized for the last 3+ consecutive checks
+            interval *= 2;
+        }
+        if (this.level().getGameTime() % interval == 0) {
+            // offset Y for short blocks like dirt_path/farmland
+            this.isLobotomized = !canTravelFrom(BlockPos.containing(this.position().x, this.getBoundingBox().minY + 0.0625D, this.position().z));
+
+            if (this.isLobotomized) {
+                this.notLobotomizedCount = 0;
+            } else {
+                this.notLobotomizedCount++;
+            }
+        }
+        return this.isLobotomized;
+    }
+
+    private boolean canTravelFrom(BlockPos pos) {
+        return canTravelTo(pos.east()) || canTravelTo(pos.west()) || canTravelTo(pos.north()) || canTravelTo(pos.south());
+    }
+
+    private boolean canTravelTo(BlockPos pos) {
+        net.minecraft.world.level.block.state.BlockState state = this.level().getBlockStateIfLoaded(pos);
+        if (state == null) {
+            // chunk not loaded
+            return false;
+        }
+        net.minecraft.world.level.block.Block bottom = state.getBlock();
+        if (bottom instanceof net.minecraft.world.level.block.FenceBlock ||
+                bottom instanceof net.minecraft.world.level.block.FenceGateBlock ||
+                bottom instanceof net.minecraft.world.level.block.WallBlock) {
+            // bottom block is too tall to get over
+            return false;
+        }
+        net.minecraft.world.level.block.Block top = level().getBlockState(pos.above()).getBlock();
+        // only if both blocks have no collision
+        return !bottom.hasCollision && !top.hasCollision;
+    }
+
     @Override
     public Brain<Villager> getBrain() {
         return (Brain<Villager>) super.getBrain(); // CraftBukkit - decompile error
@@ -293,11 +336,21 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         // Paper start
         this.customServerAiStep(false);
     }
-    protected void customServerAiStep(final boolean inactive) {
+    protected void customServerAiStep(boolean inactive) { // Purpur - not final
         // Paper end
         this.level().getProfiler().push("villagerBrain");
+        // Purpur start
+        if (this.level().purpurConfig.villagerLobotomizeEnabled) {
+            // treat as inactive if lobotomized
+            inactive = inactive || checkLobotomized();
+        } else {
+            // clean up state for API
+            this.isLobotomized = false;
+        }
         if (!inactive) this.getBrain().tick((ServerLevel) this.level(), this); // Paper
         //            if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider // Purpur - TODO: Uncomment when pufferfish patch
+        else if (this.isLobotomized && shouldRestock()) restock();
+        // Purpur end
         this.level().getProfiler().pop();
         if (this.assignProfessionWhenSpawned) {
             this.assignProfessionWhenSpawned = false;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
index e986767316a717bdbdff7a9ccaaeba068ab2a6d8..4d0b37957eb02b5d48beb76295ebc7c419ae9ca6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
@@ -223,4 +223,11 @@ public class CraftVillager extends CraftAbstractVillager implements Villager {
         getHandle().getGossips().gossips.clear();
     }
     // Paper end
+
+    // Purpur start
+    @Override
+    public boolean isLobotomized() {
+        return getHandle().isLobotomized();
+    }
+    // Purpur end
 }
diff --git a/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java b/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java
index 27b5d3f48db08721de0056d3b7b5d2f1cbe708fc..b6d0438a8a135e38a4c3284e71f6d324ca42291c 100644
--- a/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java
+++ b/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java
@@ -2290,6 +2290,8 @@ public class PurpurWorldConfig {
     public boolean villagerAllowTrading = true;
     public boolean villagerAlwaysDropExp = false;
     public int villagerMinimumDemand = 0;
+    public boolean villagerLobotomizeEnabled = false;
+    public int villagerLobotomizeCheckInterval = 100;
     private void villagerSettings() {
         if (PurpurConfig.version < 10) {
             double oldValue = getDouble("mobs.villager.attributes.max-health", villagerMaxHealth);
@@ -2306,6 +2308,17 @@ public class PurpurWorldConfig {
         villagerAllowTrading = getBoolean("mobs.villager.allow-trading", villagerAllowTrading);
         villagerAlwaysDropExp = getBoolean("mobs.villager.always-drop-exp", villagerAlwaysDropExp);
         villagerMinimumDemand = getInt("mobs.villager.minimum-demand", villagerMinimumDemand);
+        if (PurpurConfig.version < 9) {
+            boolean oldValue = getBoolean("mobs.villager.lobotomize-1x1", villagerLobotomizeEnabled);
+            set("mobs.villager.lobotomize.enabled", oldValue);
+            set("mobs.villager.lobotomize-1x1", null);
+        }
+        if (PurpurConfig.version < 27) {
+            int oldValue = getInt("mobs.villager.lobotomize.check-interval", villagerLobotomizeCheckInterval);
+            set("mobs.villager.lobotomize.check-interval", oldValue == 60 ? 100 : oldValue);
+        }
+        villagerLobotomizeEnabled = getBoolean("mobs.villager.lobotomize.enabled", villagerLobotomizeEnabled);
+        villagerLobotomizeCheckInterval = getInt("mobs.villager.lobotomize.check-interval", villagerLobotomizeCheckInterval);
     }
 
     public double vindicatorMaxHealth = 24.0D;
